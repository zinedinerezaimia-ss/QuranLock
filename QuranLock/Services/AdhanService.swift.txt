import Foundation
import AVFoundation
import UserNotifications

@MainActor
final class AdhanService: ObservableObject {
    static let shared = AdhanService()

    private let adhanURL = "https://www.islamcan.com/audio/adhan/azan1.mp3"
    private let adhanFileName = "adhan.mp3"

    @Published var isDownloaded: Bool = false
    @Published var isDownloading: Bool = false
    @Published var adhanEnabled: Bool = true
    @Published var adhanPerPrayer: [String: Bool] = [
        "Fajr": true, "Dhuhr": true, "Asr": true, "Maghrib": true, "Isha": true
    ]

    private var player: AVAudioPlayer?

    private init() {
        isDownloaded = FileManager.default.fileExists(atPath: localAdhanPath.path)
        let key = "adhan_enabled_pref"
        adhanEnabled = UserDefaults.standard.object(forKey: key) == nil
            ? true : UserDefaults.standard.bool(forKey: key)
        for prayer in adhanPerPrayer.keys {
            let k = "adhan_\(prayer)_enabled"
            if UserDefaults.standard.object(forKey: k) != nil {
                adhanPerPrayer[prayer] = UserDefaults.standard.bool(forKey: k)
            }
        }
    }

    var localAdhanPath: URL {
        FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
            .appendingPathComponent(adhanFileName)
    }

    func downloadAdhanIfNeeded() async {
        guard !isDownloaded && !isDownloading else { return }
        isDownloading = true
        guard let url = URL(string: adhanURL) else { isDownloading = false; return }
        do {
            let (data, response) = try await URLSession.shared.data(from: url)
            guard let http = response as? HTTPURLResponse, http.statusCode == 200 else {
                isDownloading = false; return
            }
            try data.write(to: localAdhanPath)
            isDownloaded = true
            isDownloading = false
        } catch {
            isDownloading = false
            print("‚ùå Adhan download error: \(error)")
        }
    }

    func playAdhan() {
        guard isDownloaded else { Task { await downloadAdhanIfNeeded() }; return }
        do {
            try AVAudioSession.sharedInstance().setCategory(.playback)
            try AVAudioSession.sharedInstance().setActive(true)
            player = try AVAudioPlayer(contentsOf: localAdhanPath)
            player?.play()
        } catch { print("‚ùå Adhan play error: \(error)") }
    }

    func stopAdhan() {
        player?.stop()
        try? AVAudioSession.sharedInstance().setActive(false)
    }

    func schedulePrayerAdhan(prayerName: String, at date: Date) {
        guard adhanEnabled, adhanPerPrayer[prayerName] == true else { return }

        let identifier = "adhan_\(prayerName.lowercased())"
        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: [identifier])

        let content = UNMutableNotificationContent()
        content.title = "üïå \(prayerName)"
        content.body = "C'est l'heure de la pri√®re de \(prayerName)"
        content.interruptionLevel = .timeSensitive

        if isDownloaded,
           let attachment = try? UNNotificationAttachment(
               identifier: "adhan_audio",
               url: localAdhanPath,
               options: [UNNotificationAttachmentOptionsTypeHintKey: "public.mp3"]
           ) {
            content.attachments = [attachment]
        } else {
            content.sound = .default
        }

        let comps = Calendar.current.dateComponents([.hour, .minute], from: date)
        let trigger = UNCalendarNotificationTrigger(dateMatching: comps, repeats: true)
        let request = UNNotificationRequest(identifier: identifier, content: content, trigger: trigger)
        UNUserNotificationCenter.current().add(request)
    }

    func scheduleAllAdhan(prayerTimes: PrayerTimes) {
        let prayers: [(String, Date)] = [
            ("Fajr", prayerTimes.fajr),
            ("Dhuhr", prayerTimes.dhuhr),
            ("Asr", prayerTimes.asr),
            ("Maghrib", prayerTimes.maghrib),
            ("Isha", prayerTimes.isha)
        ]
        for (name, time) in prayers {
            schedulePrayerAdhan(prayerName: name, at: time)
        }
    }

    func cancelAllAdhan() {
        let ids = ["adhan_fajr", "adhan_dhuhr", "adhan_asr", "adhan_maghrib", "adhan_isha"]
        UNUserNotificationCenter.current().removePendingNotificationRequests(withIdentifiers: ids)
    }

    func savePreferences() {
        UserDefaults.standard.set(adhanEnabled, forKey: "adhan_enabled_pref")
        for (prayer, enabled) in adhanPerPrayer {
            UserDefaults.standard.set(enabled, forKey: "adhan_\(prayer)_enabled")
        }
    }
}